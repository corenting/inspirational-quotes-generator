"""Handle the generation of the quote."""

import json
import random
import re

from curl_cffi.requests import AsyncSession
from curl_cffi.requests.exceptions import Timeout
from loguru import logger

from roboquote import config
from roboquote.entities.exceptions import CannotGenerateQuoteError
from roboquote.entities.large_language_model import (
    LargeLanguageModel,
    LargeLanguageModelAPI,
)

PROMPT_CONTINUE = [
    "On a {background_search_query} themed picture, "
    + "there was a fitting inspirational quote: ",
    "On a {background_search_query} themed inspirational picture, "
    + "there was a fitting inspirational short quote: ",
    "On a {background_search_query} themed inspirational picture, "
    + "there was a fitting short quote: ",
]

PROMPT_CHAT = """
Return an inspirational quote
that fits on a {background_search_query} themed picture,
similar to old Tumblr pictures.

The quote must exactly one sentence.
You must return the quote text directly.
The quote must be in {quote_language}.
Do not include any quote characters such as \", “, « or ” .
"""


def _get_random_prompt(background_search_query: str, quote_language: str) -> str:
    """Get a random prompt for the model."""

    prompt = PROMPT_CHAT.format(
        background_search_query=background_search_query, quote_language=quote_language
    )

    # Randomly replace "picture" with "photography"
    if random.randint(0, 1) == 0:
        prompt = prompt.replace("picture ", "photography ")
        prompt = prompt.replace("picture,", "photography,")
        prompt = prompt.replace("picture.", "photography.")

    return prompt


def _cleanup_text(generated_text: str) -> str:
    """Cleanup the text generated by the model.

    Remove quotes, and limit the text to the first sentence.
    """
    logger.debug(f'Cleaning up quote: "{generated_text}"')

    cleaned_quote = generated_text.strip()
    regex_quotes_list = r"\"\“\«\”"

    # First, if we match only one quote, return this one
    single_quote_regex = (
        rf"[{regex_quotes_list}]([^{regex_quotes_list}]*)[{regex_quotes_list}]"
    )
    single_quote_results = re.findall(single_quote_regex, cleaned_quote)
    if len(single_quote_results) == 1:
        cleaned_quote = single_quote_results[0]
    else:
        # Else, if the model generated a quoted text, try to get text inside quote.
        # Get the longest string in case we match some smaller fragments of text.
        built_regex = (
            rf"[{regex_quotes_list}]*([^{regex_quotes_list}]+)[{regex_quotes_list}]*"
        )
        regex_results = re.findall(
            built_regex,
            cleaned_quote,
        )
        if len(regex_results) > 0:
            cleaned_quote = max(regex_results, key=len)

        # Remove other lines if multiple lines
        cleaned_quote = cleaned_quote.partition("\n")[0]

    logger.debug(f"Cleaned quote: {cleaned_quote}")
    return cleaned_quote


async def _get_quote_from_groq_cloud(model: LargeLanguageModel, prompt: str) -> str:
    """
    Get a quote using GroqCloud for the given model and prompt.
    """
    headers = {
        "Authorization": f"Bearer {config.GROQ_CLOUD_API_KEY}",
        "Content-Type": "application/json",
    }
    data = {"messages": [{"role": "user", "content": prompt}], "model": model.name}

    async with AsyncSession() as client:
        try:
            response = await client.post(
                "https://api.groq.com/openai/v1/chat/completions",
                headers=headers,
                json=data,
                timeout=15,
            )
        except Timeout as e:
            raise CannotGenerateQuoteError("Timeout when calling GroqCloud API") from e

    # Error case with error message
    if not response.ok:
        error = "Unknown error"
        try:
            error: str = response.json()["error"]
        except (KeyError, json.JSONDecodeError):
            error = response.reason
        finally:
            raise CannotGenerateQuoteError(
                f'Error when calling GroqCloud API: "{error}"'
            )

    try:
        response_content = json.loads(response.content.decode("utf-8"))
        logger.debug(
            f"GroqCloud API response {response.status_code}: {response_content}"
        )
    except json.JSONDecodeError as e:
        raise CannotGenerateQuoteError() from e

    text: str = response_content["choices"][0]["message"]["content"]
    return text


async def get_random_quote(
    background_search_query: str, text_model: LargeLanguageModel, quote_language: str
) -> str:
    """For a given background category, get a random quote."""
    prompt = _get_random_prompt(background_search_query, quote_language)
    logger.debug(f'Prompt for {text_model.name}: "{prompt}"')

    if text_model.api == LargeLanguageModelAPI.GROQ_CLOUD:
        text = await _get_quote_from_groq_cloud(text_model, prompt)
    else:
        raise ValueError("API not supported")

    return _cleanup_text(text)
